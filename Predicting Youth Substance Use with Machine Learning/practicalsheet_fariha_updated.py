# -*- coding: utf-8 -*-
"""PracticalSheet-Fariha-Updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1udRMdL7C8QJqIdzbsQaoM8n_62jL67LG
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import preprocessing
import matplotlib.pyplot as plt
from sklearn.tree import DecisionTreeClassifier, export_text, plot_tree
from sklearn.preprocessing import OneHotEncoder, LabelBinarizer
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.metrics import confusion_matrix, accuracy_score

import pandas as pd
df = pd.read_csv('youth_data.csv')
df.columns = df.columns.str.upper()
df.head()

missing_values = df.isnull().sum()

print(missing_values)

# Substance-related variables
substance_cols = [
    'IRALCFY', 'IRMJFY', 'IRCIGFM', 'IRSMKLSS30N', 'IRALCFM', 'IRMJFM',
    'IRCIGAGE', 'IRSMKLSSTRY', 'IRALCAGE', 'IRMJAGE',
    'MRJFLAG', 'ALCFLAG', 'TOBFLAG',
    'ALCYDAYS', 'MRJYDAYS', 'ALCMDAYS', 'MRJMDAYS', 'CIGMDAYS', 'SMKLSMDAYS'
]

# Demographics
demographic_cols = [
    'IRSEX', 'NEWRACE2', 'HEALTH2', 'EDUSCHLGO', 'EDUSCHGRD2', 'EDUSKPCOM',
    'IMOTHER', 'IFATHER', 'INCOME', 'GOVTPROG', 'POVERTY3', 'PDEN10', 'COUTYP4'
]
df_demograpic = df[demographic_cols]
# Youth experience columns: from SCHFELT to RLGFRND
youth_start = df.columns.get_loc('SCHFELT')
youth_end = df.columns.get_loc('RLGFRND')
youth_experience_cols = df.columns[youth_start:youth_end+1].tolist()

df.dropna(subset=youth_experience_cols, inplace=True)
df.shape

"""# Finding Correlation among variables"""

# Step 1: Load data (assuming df is already loaded and filtered)
df_youth = df.loc[:, 'SCHFELT':'RLGFRND']  # Adjust if your youth columns differ
df_corr = df_youth.copy()
df_corr["MRJFLAG"] = df["MRJFLAG"]

# Step 2: Encode all categorical variables
df_corr = df_corr.apply(lambda col: pd.factorize(col)[0] if col.dtypes == 'object' or col.dtypes.name == 'category' else col)

# Step 3: Compute correlations
correlations = df_corr.corr()["MRJFLAG"].drop("MRJFLAG").sort_values(ascending=False)

# Step 4: Display top and bottom correlations
print("\n Top correlated features with MRJFLAG:")
print(correlations.head(10))

print("\n Least correlated features with MRJFLAG:")
print(correlations.tail(10))

#drop . from dataframe

df = df[df != '.'].dropna()

"""# Binary Classification

Only those correlated variables which has correlation > 20
"""

#Filter correlations > 0.20 or < -0.20
strong_correlations = correlations[correlations > 0.20]
strong_correlations

"""FRDMJMON : CLSE FRNDS FEEL ABT YTH USE MARIJUANA MON

YFLMJMO: HOW YTH FEELS: PEERS USING MARIJUANA MONTHLY

FRDMEVR2: -YTH THINK: CLOSE FRNDS FEEL ABT YTH TRY MARIJUANA

YFLTMRJ2: -HOW YTH FEELS: PEERS TRY MARIJUANA

PRMJMO: -YTH THINK: PARENTS FEEL ABT YTH USE MARIJUANA MNTHLY

PRMJEVR2: YTH THINK: PARENTS FEEL ABT YTH TRY MARIJUANA

The following indicators are highly correlated to the target variavble which is MRJFLAG. It means the peer indicators and parental indicators have influenced on the youth if they have ever usd marijuana

## Decision Tree

Whether their friends or peers use marijuana
"""

# === Filter to those who answered youth experience questions ===
df = df[df['SCHFELT'].notna()].copy()

# === Define peer influence features ===
peer_features = ['FRDMJMON', 'YFLMJMO', 'FRDMEVR2', 'YFLTMRJ2', 'PRMJMO','PRMJEVR2']

# === Target variable ===
target = 'MRJFLAG'

# === Drop rows with missing values in selected features or target ===
df_model = df[peer_features + [target]].dropna()

# === Convert to numeric if needed (factorization for categorical) ===
for col in peer_features:
    if df_model[col].dtype == 'object':
        df_model[col] = pd.factorize(df_model[col])[0]

# === Define X and y ===
X = df_model[peer_features]
y = df_model[target]

# === Train/test split ===
X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, test_size=0.3, random_state=42
)

# === Fit decision tree ===
dt = DecisionTreeClassifier(max_depth=5, random_state=42, class_weight="balanced")
dt.fit(X_train, y_train)

# === Predict ===
y_pred = dt.predict(X_test)

# === Evaluate ===
print(" Decision Tree Results")
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

# === Plot the tree ===
plt.figure(figsize=(20, 10))
plot_tree(dt, feature_names=peer_features, class_names=["No", "Yes"], filled=True)
plt.title("Decision Tree: Predicting Marijuana Use from Peer Influence")
plt.show()

"""This tree is answering:

Can we reasonably predict if a youth used marijuana recently based on peer influence, using a simple model?

Answer: Yes, to a good extent. Your model has decent accuracy and is fair at identifying users.

## Pruned Tree
"""

df_model = df[peer_features + [target]].dropna()


X = df_model[peer_features]
y = df_model[target]

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, test_size=0.3, random_state=42
)

# === Pruning with GridSearchCV ===
param_grid = {'max_depth': range(2, 15), 'min_samples_leaf': [1, 5, 10]}
grid = GridSearchCV(
    DecisionTreeClassifier(random_state=42, class_weight="balanced"),
    param_grid,
    cv=5,
    scoring='f1',  # F1 balances precision and recall for class 1
    n_jobs=-1
)
grid.fit(X_train, y_train)

# Best model
best_dt = grid.best_estimator_

# Evaluation
y_pred = best_dt.predict(X_test)

print("Pruned Decision Tree Results")
print("Best Parameters:", grid.best_params_)
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

# Plot tree
plt.figure(figsize=(20, 10))
plot_tree(best_dt, feature_names=peer_features, class_names=["No", "Yes"], filled=True)
plt.title("Pruned Decision Tree: Predicting Marijuana Use from Peer Influence")
plt.show()

"""Can we build a balanced, interpretable model to predict recent youth marijuana use based on peer influence factors?

Yes â€” this pruned tree gives you:

Strong recall for identifying users (important if the goal is early intervention)

Good accuracy and interpretability

Less overfitting compared to a deep tree
"""

from sklearn.model_selection import GridSearchCV
from sklearn.tree import DecisionTreeClassifier
import matplotlib.pyplot as plt

# Define parameter grid
params = {'max_leaf_nodes': range(2, 15)}

# Set up GridSearchCV
grid = GridSearchCV(
    estimator=DecisionTreeClassifier(random_state=42),
    param_grid=params,
    cv=5,
    scoring='accuracy',
    return_train_score=True
)

# Fit the grid search
grid.fit(X_train, y_train)

# Get best parameters and score
best_size = grid.best_params_['max_leaf_nodes']
best_score = grid.best_score_

# Plot results
plt.figure(figsize=(6, 4))
plt.plot(grid.cv_results_['param_max_leaf_nodes'], grid.cv_results_['mean_test_score'], 'o-', label='CV Accuracy')
plt.plot(best_size, best_score, 'ro', label='Best Size')
plt.xlabel('Tree Size (max_leaf_nodes)')
plt.ylabel('Cross-Validated Accuracy')
plt.title('Cross-validation Results for Tree Size')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""## Random Forest"""

from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

# === Use the same X and y from earlier ===
# (X, y already filtered, encoded, and split from pruned tree code)

# === Random Forest with Grid Search ===
rf_params = {'n_estimators': [100], 'max_depth': [3, 6, 9]}
rf_model = GridSearchCV(
    RandomForestClassifier(random_state=42),
    param_grid=rf_params,
    scoring='f1',
    cv=5,
    n_jobs=-1
)
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

print("\n Random Forest Results")
print("Best Parameters:", rf_model.best_params_)
print("Accuracy:", accuracy_score(y_test, y_pred_rf))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred_rf))
print("Classification Report:\n", classification_report(y_test, y_pred_rf))

# Define parameter grid for max_leaf_nodes
param_grid = {'max_leaf_nodes': range(2, 15)}

# Initialize GridSearchCV
grid = GridSearchCV(
    estimator=RandomForestClassifier(
        n_estimators=100,
        random_state=42,
        class_weight="balanced"  # Optional, if data is imbalanced
    ),
    param_grid=param_grid,
    cv=5,
    scoring='accuracy',
    return_train_score=True
)

# Fit to training data
grid.fit(X_train, y_train)

# Extract best params and score
best_size = grid.best_params_['max_leaf_nodes']
best_score = grid.best_score_

# Plot cross-validation accuracy vs tree size
plt.figure(figsize=(8, 5))
plt.plot(grid.cv_results_['param_max_leaf_nodes'], grid.cv_results_['mean_test_score'], marker='o', label='CV Accuracy')
plt.axvline(best_size, color='red', linestyle='--', label=f'Best Size: {best_size}')
plt.xlabel('max_leaf_nodes (Tree Size)')
plt.ylabel('Cross-Validated Accuracy')
plt.title('Optimal Tree Size for RandomForestClassifier')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Print best result
print(f"Best Tree Size (max_leaf_nodes): {best_size}")
print(f"Best Cross-Validated Accuracy: {best_score:.4f}")

"""## Gradient Boosting"""

# === Gradient Boosting with Grid Search ===
gb_params = {'learning_rate': [0.01, 0.05], 'n_estimators': [100, 200], 'max_depth': [3, 5]}
gb_model = GridSearchCV(
    GradientBoostingClassifier(random_state=42),
    param_grid=gb_params,
    scoring='f1',
    cv=5,
    n_jobs=-1
)
gb_model.fit(X_train, y_train)
y_pred_gb = gb_model.predict(X_test)

print("\n Gradient Boosting Results")
print("Best Parameters:", gb_model.best_params_)
print("Accuracy:", accuracy_score(y_test, y_pred_gb))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred_gb))
print("Classification Report:\n", classification_report(y_test, y_pred_gb))

tree_ = DecisionTreeClassifier(random_state=1)
tree_.fit(X_train, y_train)
params = {'max_leaf_nodes': range(2, 25)}
cv = GridSearchCV(tree_, params, cv=10)
cv.fit(X_train, y_train)
cv_results = cv.cv_results_
best_size = cv.best_params_['max_leaf_nodes']
best_score = cv.best_score_
plt.figure(figsize=(6, 4))
plt.plot(cv_results["param_max_leaf_nodes"], cv_results["mean_test_score"], 'o-')
plt.plot(best_size, best_score, 'ro-')
plt.xlabel('Tree Size')
plt.ylabel('Accuracy')
plt.title('Cross-validation Results');

"""## Bagging"""

X = df_model[peer_features]
y = df_model[target]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, test_size=0.3, random_state=42
)

# Fit Bagging model (Random Forest)
bagging_model = RandomForestClassifier(
    max_features=X_train.shape[1],
    n_estimators=25,
    random_state=1,
    class_weight="balanced"
)

bagging_model.fit(X_train, y_train)

# Predictions
y_pred = bagging_model.predict(X_test)
y_proba = bagging_model.predict_proba(X_test)[:, 1]

# Evaluation
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error: {:.2f}".format(mse))
print("Number of trees:", bagging_model.n_estimators)
print("Number of features tried at each split:", bagging_model.max_features)
print("Training score: {:.2f}%".format(bagging_model.score(X_train, y_train) * 100))
print("Test score: {:.2f}%".format(bagging_model.score(X_test, y_test) * 100))

# Classification report using thresholded probabilities
y_pred_thresh = (y_proba > 0.5).astype(int)
print(classification_report(y_test, y_pred_thresh))

np.bincount(y_train)  # or pd.Series(y_train).value_counts()

"""The training data is heavily imbalanced:

Class 0: 4,837 samples

Class 1: 937 samples
So, ~84% of your data is Class 0.

# Multi class Classification

## Decision Tree

# Finding Correlation among variables
"""

# Step 1: Load data (assuming df is already loaded and filtered)
df_youth = df.loc[:, 'SCHFELT':'RLGFRND']  # Adjust if your youth columns differ
df_corr = df_youth.copy()
df_corr["MRJYDAYS"] = df["MRJYDAYS"]

# Step 2: Encode all categorical variables
df_corr = df_corr.apply(lambda col: pd.factorize(col)[0] if col.dtypes == 'object' or col.dtypes.name == 'category' else col)

# Step 3: Compute correlations
correlations = df_corr.corr()["MRJYDAYS"].drop("MRJYDAYS").sort_values(ascending=False)

# Step 4: Display top and bottom correlations
print("\n Top correlated features with MRJYDAYS:")
print(correlations.head(10))

print("\n Least correlated features with MRJYDAYS:")
print(correlations.tail(10))

strong_correlations = correlations[correlations > 0.10]
strong_correlations

"""STNDSMJ: Perceived risk of using marijuana regularly.

STNDALC: Perceived risk of using alcohol regularly

The above two indicators are highly correlated with MRJYDAYS

"In this multiclass classification task, we aim to predict the frequency of marijuana use (MRJYDAYS) among youth using their perceived risk of marijuana (STNDSMJ) and alcohol (STNDALC). The goal is to understand how substance risk perception correlates with actual usage behavior and whether these insights can guide prevention strategies."
"""

# Step 1: Define the mapping
def remap_mrjydays(value):
    if value in [1, 2]:
        return 0  # light
    elif value in [3, 4]:
        return 1  # moderate
    elif value in [5, 6]:
        return 2  # heavy
# === Define peer influence features ===
features = ['STNDSMJ', 'STNDALC', 'YOSTOLE2', 'STNDDNK','YOSELL2'	]

# Step 2: Create the model DataFrame (subset + dropna first)
df_model = df[features + ['MRJYDAYS']].dropna()

# Step 3: Apply the mapping
df_model['MRJYDAYS'] = df_model['MRJYDAYS'].apply(remap_mrjydays)

# Step 4: Factorize categorical columns
for col in features:
    if df_model[col].dtype == 'object':
        df_model[col] = pd.factorize(df_model[col])[0]

# Step 5: Define features and target
X = df_model[features]
y = df_model['MRJYDAYS']

# === Train/test split ===
X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, test_size=0.3, random_state=42
)

# === Fit decision tree ===
dt = DecisionTreeClassifier(max_depth=5, class_weight="balanced", random_state=42)
dt.fit(X_train, y_train)

# === Predict ===
y_pred = dt.predict(X_test)

# === Evaluate ===
print("Decision Tree Results")
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

# === Plot the tree ===
# Convert class labels to string to display in the tree
class_labels = ['Light', 'Moderate', 'Heavy']

plt.figure(figsize=(20, 10))
plot_tree(
    dt,
    feature_names=peer_features,
    class_names=class_labels,
    filled=True,
    rounded=True,
    fontsize=10
)
plt.title("Decision Tree: Predicting Marijuana Use (MRJYDAYS)")
plt.show()

"""model is heavily biased toward the majority class (class 2: Heavy users). This is very common when you have class imbalance in the target variable


"""

tree_ = DecisionTreeClassifier(random_state=1)
tree_.fit(X_train, y_train)
params = {'max_leaf_nodes': range(2, 25)}
cv = GridSearchCV(tree_, params, cv=10)
cv.fit(X_train, y_train)
cv_results = cv.cv_results_
best_size = cv.best_params_['max_leaf_nodes']
best_score = cv.best_score_
plt.figure(figsize=(6, 4))
plt.plot(cv_results["param_max_leaf_nodes"], cv_results["mean_test_score"], 'o-')
plt.plot(best_size, best_score, 'ro-')
plt.xlabel('Tree Size')
plt.ylabel('Accuracy')
plt.title('Cross-validation Results');

"""## Pruned Tree"""

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, test_size=0.3, random_state=42
)

# === Pruning with GridSearchCV ===
param_grid = {'max_depth': range(5, 15), 'min_samples_leaf': [2,10]}
grid = GridSearchCV(
    DecisionTreeClassifier(random_state=42, class_weight='balanced'),
    param_grid,
    cv=5,
    scoring='f1_macro',
    n_jobs=-1
)
grid.fit(X_train, y_train)

# Best model
best_dt = grid.best_estimator_

# Evaluation
y_pred = best_dt.predict(X_test)

print("Pruned Decision Tree Results")
print("Best Parameters:", grid.best_params_)
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

# === Plot the pruned tree ===
class_labels = ['1', '2', '3', '4', '5', '6']

plt.figure(figsize=(20, 10))
plot_tree(
    best_dt,
    feature_names=features,
    class_names=class_labels,
    filled=True,
    rounded=True,
    fontsize=10
)
plt.title("Pruned Decision Tree: Predicting Marijuana Use (MRJYDAYS)")
plt.show()

"""## Random Forest"""

# === Random Forest with Grid Search ===
rf_params = {'n_estimators': [100], 'max_depth': [3, 6, 9]}
rf_model = GridSearchCV(
    RandomForestClassifier(random_state=42, class_weight="balanced"),
    param_grid=rf_params,
    scoring='f1',
    cv=5,
    n_jobs=-1
)
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

print("\n Random Forest Results")
print("Best Parameters:", rf_model.best_params_)
print("Accuracy:", accuracy_score(y_test, y_pred_rf))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred_rf))
print("Classification Report:\n", classification_report(y_test, y_pred_rf))

"""Majority Class (2 - Heavy):
*   The model is really good at identifying heavy users (class 2).

*   Thatâ€™s expected because ~88% of your data belongs to this class.


Minority Classes (0 - Light, 1 - Moderate):

*   These are still underperforming.
*   Class 1 has decent recall (63%), but very poor precision (13%) â†’ lots of false positives.

Class 0 is barely being learned.

Overall Accuracy â‰ˆ 64%:

## Gradient Boosting
"""

# === Gradient Boosting with Grid Search ===
gb_params = {'learning_rate': [0.01, 0.05], 'n_estimators': [50, 100], 'max_depth': [3,7]}
gb_model = GridSearchCV(
    GradientBoostingClassifier(random_state=42),
    param_grid=gb_params,
    scoring='f1_macro',
    cv=5,
    n_jobs=-1
)
gb_model.fit(X_train, y_train)
y_pred_gb = gb_model.predict(X_test)

print("\n Gradient Boosting Results")
print("Best Parameters:", gb_model.best_params_)
print("Accuracy:", accuracy_score(y_test, y_pred_gb))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred_gb))
print("Classification Report:\n", classification_report(y_test, y_pred_gb))

"""Model predicts Heavy use (2) very well
Performs poorly on Light (0) and Moderate (1) categories:

Almost all are misclassified as Heavy

Class 0: 0% recall, 0% precision

Improvement Using Class Weights

This approach ensures your model pays more attention to minority classes during training â€” a smart fix for your previous imbalance problem.
"""

from sklearn.utils.class_weight import compute_sample_weight
sample_weights = compute_sample_weight(class_weight='balanced', y=y_train)

gb_model = GridSearchCV(
    GradientBoostingClassifier(random_state=42),
    param_grid=gb_params,
    scoring='f1_macro',
    cv=5,
    n_jobs=-1
)
gb_model.fit(X_train, y_train, sample_weight=sample_weights)  # <- okay for grid search

y_pred_bal = gb_model.predict(X_test)
print("Accuracy:", accuracy_score(y_test, y_pred_bal))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred_bal))
print("Classification Report:\n", classification_report(y_test, y_pred_bal))

"""Earlier the accuracy was 88% accuracy which sounds good â€” but itâ€™s just predicting the majority class. (class imbalance issue)

After improving the class weight the accuracy dropped slightly to 64%, but thatâ€™s expected â€” the model is no longer just optimizing for the majority class.

Class 0 and 1 now have much better recall, meaning the model is catching more true instances of minority classes.

## Bagging
"""

# Fit Bagging model (Random Forest)
bagging_model = RandomForestClassifier(
    max_features=X_train.shape[1],
    n_estimators=25,
    random_state=1,
    class_weight="balanced"
)

bagging_model.fit(X_train, y_train)

# Standard predictions (no thresholding)
y_pred = bagging_model.predict(X_test)

# Evaluation
print("Mean Squared Error: {:.2f}".format(mean_squared_error(y_test, y_pred)))
print("Training score: {:.2f}%".format(bagging_model.score(X_train, y_train) * 100))
print("Test score: {:.2f}%".format(bagging_model.score(X_test, y_test) * 100))

# Classification report
from sklearn.metrics import classification_report, confusion_matrix
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

"""# Regression

To what extent do behaviors such as physical fights (YOFIGHT2), group fights (YOGRPFT2), theft (YOSTOLE2), communication problems with parents or peers (TALKPROB), and violent attacks (YOATTAK2) predict the age of first alcohol use (IRALCAGE)?"
"""

required_columns =  youth_experience_cols + ['IRALCAGE']
df_r = df[required_columns]
print(df_r.shape)

"""Keeps only respondents who started drinking at age 7 or older, and

Removes those who never drank alcohol.
"""

df_r = df_r[df_r['IRALCAGE'] >= 7]
df_r.shape

df_r = df_r[df_r['IRALCAGE'] != 991]
df_r.shape

"""# Finding Correlation among variables"""

df_corr = df_youth.copy()
df_corr["IRALCAGE"] = df_r["IRALCAGE"]

# Step 2: Encode all categorical variables
df_corr = df_corr.apply(lambda col: pd.factorize(col)[0] if col.dtypes == 'object' or col.dtypes.name == 'category' else col)

# Step 3: Compute correlations
correlations = df_corr.corr()["IRALCAGE"].drop("IRALCAGE").sort_values(ascending=False)

# Step 4: Display top and bottom correlations
print("\n Top correlated features with IRALCAGE:")
print(correlations.head(10))

print("\n Least correlated features with IRALCAGE:")
print(correlations.tail(10))

strong_correlations = correlations[correlations > 0.10]
strong_correlations

# === Define features ===
features = ['YOFIGHT2', 'YOGRPFT2','YOSTOLE2','TALKPROB','YOATTAK2']

# === Target variable ===
target = 'IRALCAGE'

# === Drop rows with missing values in selected features or target ===
df_model = df_r[features + [target]].dropna()

# === Convert to numeric if needed (factorization for categorical) ===
for col in features:
    if df_model[col].dtype == 'object':
        df_model[col] = pd.factorize(df_model[col])[0]

# === Define X and y ===
X = df_model[features]
y = df_model[target]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""## Decision Tree"""

from sklearn.tree import DecisionTreeRegressor

tree = DecisionTreeRegressor(random_state = 1)
tree.fit(X_train,y_train)
MSE = ((y_test - tree.predict(X_test))**2).mean()
print(MSE)

importance = pd.DataFrame({'feature': X_train.columns, 'importance': tree.feature_importances_}).sort_values('importance', ascending=False)
importance.head(10)

"""## Pruning"""

tree1 = DecisionTreeRegressor(random_state = 1)
tree1.fit(X_train, y_train)
params = {'max_leaf_nodes': range(2, 10)}
cv_tree1 = GridSearchCV(tree1, params, cv=20)
cv_tree1.fit(X_train, y_train)
cv_results = cv_tree1.cv_results_
best_size = cv_tree1.best_params_['max_leaf_nodes']
best_score = cv_tree1.best_score_
print('Best tree size: ',best_size)

plt.figure(figsize=(7, 4))
plt.plot(cv_results["param_max_leaf_nodes"].data, cv_results["mean_test_score"], 'o-')
plt.plot(best_size, best_score, 'ro-')
plt.xlabel('Tree Size')
plt.ylabel('Accuracy')
plt.title('Cross-validation Results');

prune_tree = DecisionTreeRegressor(random_state = 1, max_leaf_nodes = best_size)
prune_tree.fit(X_train, y_train)
MSE = ((y_test - prune_tree.predict(X_test))**2).mean()
print(MSE)

importances = pd.DataFrame({'feature': X_train.columns, 'importance': prune_tree.feature_importances_}).sort_values('importance', ascending=False)
importances.head(10)

"""## Random Forest

"""

rf_reg = RandomForestRegressor(max_features=20 , random_state = 1)
rf_reg.fit(X_train,y_train)
y_pred_rf = rf_reg.predict(X_test)
print("Mean Squared Error: {:.2f}".format(mean_squared_error(y_test, y_pred_rf)))

importances = pd.DataFrame({'feature': X_train.columns, 'importance': rf_reg.feature_importances_}).sort_values('importance', ascending=False)
importances.head(10)

"""## Boosting"""

boost_reg = GradientBoostingRegressor(n_estimators=100, max_depth=4
 , random_state=1)
boost_reg.fit(X_train, y_train)
y_pred_boost = boost_reg.predict(X_test)
# find the MSE
print("Mean Squared Error: {:.2f}".format(mean_squared_error(y_test, y_pred_boost)))

importances = pd.DataFrame({'feature': X_train.columns, 'importance': boost_reg.feature_importances_}).sort_values('importance', ascending=False)
importances.head(10)

"""## Bagging"""

boston_bagging = RandomForestRegressor(max_features=X_train.shape[1],random_state = 1,n_estimators=25)
boston_bagging.fit(X_train,y_train)

print("Number of trees:", boston_bagging.n_estimators)
print("Number of features tried at each split:",boston_bagging.max_features)
print("Training score: {:.2f}%".format(boston_bagging.score(X_train,y_train)*100))

# Predict values
y_pred_bag = boston_bagging.predict(X_test)

# plot predicted vs actual values
plt.scatter(y_pred_bag, y_test)
plt.plot([min(y_pred_bag), max(y_pred_bag)], [min(y_pred_bag), max(y_pred_bag)], 'r--')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')
plt.title('Bagging model');

# find the MSE
print("Mean Squared Error: {:.2f}".format(mean_squared_error(y_test, y_pred_bag)))

"""The test set MSE associated with the bagged regression tree is 3.74

# Results Interpretation

1. Binary Classification â€“ Predicting Marijuana Use (MRJFLAG)
  1.1 Decision Tree
      *   Accuracy: ~74.6%
      *   Recall (Users): 78%
      *   Precision (Users): 37%

  Insight:

      Decent recall shows it's catching many of the actual users, which is good for interventions. However, low precision indicates a high number of false positives (non-users predicted as users).

  1.2 Pruned Tree
    * Accuracy: ~78%

    * Precision (Users): 40%

    * Recall (Users): 74%

  Insight:
    
  Pruning helped balance model complexity and performance. It reduced overfitting and improved interpretability while maintaining good recall and accuracy.

  1.3 Random Forest
    * Accuracy: ~84%

    * Precision (Users): 51%

    * Recall (Users): 44%

  Insight:

  Overall a robust performer. Slight drop in recall compared to decision tree, but precision improved. Still misses many users (low recall).

  1.4 Gradient Boosting
  * Accuracy: ~84%

  * Precision (Users): 51%

  * Recall (Users): 43%

  Insight:

  Similar performance to Random Forest. Boosting is typically better at handling subtle patterns, but here it doesnâ€™t drastically outperform RF.


  1.5 Bagging

  * Accuracy : ~ 74%

  * Precision (Users) : 36%

  * Recall (Users) : 77%
  
  
  Insight:

2. Multi-Class Classification â€“ Predicting Frequency of Marijuana Use (MRJYDAYS)
(Target grouped as Light, Moderate, Heavy)

  2.1 Decision Tree
  * Accuracy: ~64%
  *Heavy Users:
  *Precision: 96%
  * Recall: 67%

  Light & Moderate Users: Very low precision & recall (under 15%)

  Insight:
  
  The model is biased toward majority class (Heavy) due to class imbalance (~88% of data). Not helpful for detecting early/mild users.

  2.2 Pruned Tree
  * Accuracy: ~60%

  * Macro F1: ~0.23 (poor across classes)

  Insight:

  Slight improvement in balance. Class 5 (moderate users) somewhat better identified. Still heavily favors heavy users. Recall improved, but model still weak on light/moderate detection.

  2.3 Random Forest

    * Accuracy: ~64.5%
    * Class 1 Recall: 63% (best among minority classes)
    * Precision remains low

  Insight:

  Better at capturing moderate users, but still low confidence in predictions (low precision). Heavy class dominates due to imbalance.

  2.4 Gradient Boosting

  * Accuracy: ~87.6% (BUT: Predicts only the majority class (Heavy) for all instances.)

  * Precision/Recall (Light & Moderate): 0

  Insight:
  This is a classic accuracy trap â€” the model learns to always predict the dominant class to maximize accuracy. Completely fails for light/moderate users.

  2.5 Bagging

  * Accuracy : 64%
  * Precision/Recall (The model predicts class 2 (the majority class) most of the time. Class 0 and 1 are being heavily misclassified) only 49% of class 0 is correctly predicted, only 38% of class 1 is correctly predicted but for class 2 67% is correctly predicited

3. Regression â€“ Predicting Age of First Alcohol Use (IRALCAGE)

3.1 Decision Tree
  
  * MSE: ~3.72

Top Features: TALKPROB, YOGRPFT2, YOATTAK2

Insight:
Simple model with reasonable performance. Shows that interpersonal issues are somewhat predictive of earlier alcohol use, but the signal is weak/moderate.

3.3 Pruned Tree

* MSE: ~3.85

Insight:
Slightly higher error, but better generalization. Sacrifices a bit of precision for robustness and interpretability.

3.5 Random Forest

* MSE: ~3.72

Top Feature: TALKPROB

Insight:
Matches unpruned treeâ€™s performance. Captures non-linear patterns, but interpretability drops. Feature importances show consistent signal with decision tree.

3.5 Gradient Boosting

* MSE: ~3.75

Insight:
Comparable to others. Could benefit from hyperparameter tuning. Works best when more granular, high-signal features are present

# Overall Summary

![PW.png](data:image/png;base64,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)
"""

